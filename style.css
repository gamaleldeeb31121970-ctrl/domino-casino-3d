<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Domino Casino Pro - Final</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; touch-action: none; font-family: 'Segoe UI', sans-serif; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .score-card { position: absolute; background: rgba(0,0,0,0.85); color: #ffd700; padding: 12px 25px; border: 2px solid #ffd700; border-radius: 12px; font-weight: bold; font-size: 16px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        #status-msg { position: absolute; bottom: 120px; width: 100%; text-align: center; color: #fff; font-size: 18px; text-shadow: 2px 2px 4px #000; }
    </style>
</head>
<body>
    <div id="overlay">
        <div class="score-card" style="top: 20px; left: 20px;">الخصم: <span id="ai-left">7</span></div>
        <div class="score-card" style="top: 20px; right: 20px;">أنت: <span id="p-left">7</span></div>
        <div id="status-msg">دورك الآن.. اسحب حجرك</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // إعدادات المشهد والكاميرا الاحترافية
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 13, 11); // زاوية هابطة لإظهار سمك الحجر
        camera.lookAt(0, -2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // إضاءة سينمائية
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const spot = new THREE.SpotLight(0xffffff, 1.2);
        spot.position.set(5, 20, 10); spot.castShadow = true;
        scene.add(spot);

        // الطاولة (Landscape)
        const table = new THREE.Mesh(new THREE.BoxGeometry(40, 0.5, 25), new THREE.MeshStandardMaterial({ color: 0x0a3d16, roughness: 0.8 }));
        table.receiveShadow = true; scene.add(table);

        let pHand = [], aiHand = [], edges = { l: {x: -1.25, v: 6}, r: {x: 1.25, v: 6} };

        // مصنع الحجارة بتخانة واقعية
        function createTile(v1, v2, x, z, owner) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.6, 2.4), // تخانة 0.6 تجعل الحجر ضخماً
                new THREE.MeshStandardMaterial({ color: 0xfdfdf5, roughness: 0.05, metalness: 0.1 })
            );
            body.castShadow = true; group.add(body);

            // المسمار والخط
            const line = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.02, 0.04), new THREE.MeshBasicMaterial({color:0x000}));
            line.position.y = 0.31; group.add(line);
            const pivot = new THREE.Mesh(new THREE.SphereGeometry(0.085, 16, 16), new THREE.MeshStandardMaterial({color:0xffd700, metalness:1}));
            pivot.position.y = 0.31; group.add(pivot);

            const drawPips = (val, zO) => {
                const g = 0.36; let pts = [];
                if(val%2!==0) pts.push([0,0]); if(val>=2) pts.push([g,g], [-g,-g]); if(val>=4) pts.push([-g,g], [g,-g]); if(val===6) pts.push([g,0], [-g,0]);
                pts.forEach(p => {
                    const pip = new THREE.Mesh(new THREE.SphereGeometry(0.1, 12, 12), new THREE.MeshStandardMaterial({color:0x111111}));
                    pip.position.set(p[0], 0.29, zO + p[1]); group.add(pip);
                });
            };

            if(owner !== 'ai') { drawPips(v1, 0.6); drawPips(v2, -0.6); }
            else { group.rotation.x = Math.PI; } // مقلوب للخصم

            group.position.set(x, 0.3, z);
            group.userData = { v1, v2, owner, ox: x, oz: z, isD: v1===v2 };
            scene.add(group);
            return group;
        }

        // توزيع "الرصة اللزق"
        const pool = []; for(let i=0; i<=6; i++) for(let j=i; j<=6; j++) pool.push([i,j]);
        pool.sort(() => Math.random() - 0.5);
        
        // مسافة 1.3 فقط بين الحجارة لتظهر متلاصقة احترافياً
        for(let i=0; i<7; i++) pHand.push(createTile(...pool.pop(), -3.9 + (i * 1.3), 8, 'p'));
        for(let i=0; i<7; i++) aiHand.push(createTile(...pool.pop(), -3.9 + (i * 1.3), -8, 'ai'));
        createTile(6, 6, 0, 0, 'board');

        // منطق السحب واللمس
        let sel = null; const ray = new THREE.Raycaster(); const mouse = new THREE.Vector2();
        window.addEventListener('touchstart', e => {
            const t = e.touches[0];
            mouse.x = (t.clientX/window.innerWidth)*2-1; mouse.y = -(t.clientY/window.innerHeight)*2+1;
            ray.setFromCamera(mouse, camera);
            const hits = ray.intersectObjects(pHand, true);
            if(hits.length > 0) {
                let o = hits[0].object; while(o.parent && o.userData.owner!=='p') o = o.parent;
                sel = o; sel.position.y = 1.5;
            }
        });

        window.addEventListener('touchmove', e => {
            if(!sel) return;
            const t = e.touches[0];
            mouse.x = (t.clientX/window.innerWidth)*2-1; mouse.y = -(t.clientY/window.innerHeight)*2+1;
            ray.setFromCamera(mouse, camera);
            const h = ray.intersectObject(table);
            if(h.length > 0) sel.position.set(h[0].point.x, 1, h[0].point.z);
        });

        window.addEventListener('touchend', () => {
            if(!sel) return;
            let played = false; const p = sel.position;
            if(p.distanceTo(new THREE.Vector3(edges.r.x, 0, 0)) < 3.5) { snap(sel, 'r'); played = true; }
            else if(p.distanceTo(new THREE.Vector3(edges.l.x, 0, 0)) < 3.5) { snap(sel, 'l'); played = true; }

            if(played) {
                pHand = pHand.filter(t => t !== sel);
                document.getElementById('p-left').innerText = pHand.length;
                setTimeout(aiMove, 1000);
            } else { sel.position.set(sel.userData.ox, 0.3, sel.userData.oz); }
            sel.position.y = 0.3; sel = null;
        });

        function aiMove() {
            let idx = aiHand.findIndex(t => t.userData.v1 === edges.l.v || t.userData.v2 === edges.l.v || t.userData.v1 === edges.r.v || t.userData.v2 === edges.r.v);
            if(idx !== -1) {
                let t = aiHand[idx]; t.rotation.x = 0;
                // إظهار النقاط عند اللعب
                const show = (v, zO) => {
                    const g = 0.36; let pts = [];
                    if(v%2!==0) pts.push([0,0]); if(v>=2) pts.push([g,g], [-g,-g]); if(v>=4) pts.push([-g,g], [g,-g]); if(v===6) pts.push([g,0], [-g,0]);
                    pts.forEach(p => {
                        const pip = new THREE.Mesh(new THREE.SphereGeometry(0.1, 12, 12), new THREE.MeshStandardMaterial({color:0x111111}));
                        pip.position.set(p[0], 0.29, zO + p[1]); t.add(pip);
                    });
                };
                show(t.userData.v1, 0.6); show(t.userData.v2, -0.6);
                if(t.userData.v1 === edges.r.v || t.userData.v2 === edges.r.v) snap(t, 'r'); else snap(t, 'l');
                aiHand.splice(idx, 1); document.getElementById('ai-left').innerText = aiHand.length;
            }
        }

        function snap(t, side) {
            const isD = t.userData.isD; const target = edges[side];
            // مسافات الالتحام "شحط" بدون فراغات
            t.position.set(side==='r' ? target.x+(isD?0.6:1.2) : target.x-(isD?0.6:1.2), 0.3, 0);
            t.rotation.y = isD ? 0 : Math.PI/2;
            target.v = (t.userData.v1 === target.v) ? t.userData.v2 : t.userData.v1;
            target.x = t.position.x + (side==='r' ? (isD?0.6:1.2) : (isD?-0.6:-1.2));
            t.userData.owner = 'board';
        }

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
