<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Domino Pro 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #051a0b; font-family: sans-serif; }
        
        /* ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØªØ´Ø¨Ù‡ Ø§Ù„ØµÙˆØ±Ø© ØªÙ…Ø§Ù…Ø§Ù‹ */
        #ui-top {
            position: absolute; top: 10px; width: 100%;
            display: flex; justify-content: space-between; padding: 0 15px;
            box-sizing: border-box; z-index: 10; pointer-events: none;
        }
        .status-pill {
            background: rgba(0,0,0,0.7); color: #ffcc00;
            padding: 5px 15px; border-radius: 20px;
            border: 1px solid #ffd700; font-size: 12px; font-weight: bold;
        }
        #game-canvas { width: 100%; height: 100%; touch-action: none; }
    </style>
</head>
<body>

    <div id="ui-top">
        <div class="status-pill">ðŸ’¸ Ø§Ù„Ø±Ù‡Ø§Ù†: 1K</div>
        <div class="status-pill">ðŸ’° Ø§Ù„Ø±ØµÙŠØ¯: 28.5M</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // 1. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ù‡Ø¯ ÙˆØ§Ù„Ù…Ø­Ø±Ùƒ
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x051a0b); // Ø®Ù„ÙÙŠØ© Ø®Ø¶Ø±Ø§Ø¡ Ø¯Ø§ÙƒÙ†Ø© Ø¬Ø¯Ø§Ù‹

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 12, 8);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ù„Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„
        document.body.appendChild(renderer.domElement);

        // 2. Ø¥Ø¶Ø§Ø¡Ø© Ø³ÙŠÙ†Ù…Ø§Ø¦ÙŠØ©
        const light1 = new THREE.DirectionalLight(0xffffff, 1);
        light1.position.set(5, 10, 5);
        scene.add(light1);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));

        // 3. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·Ø§ÙˆÙ„Ø© Ø§Ù„Ø®Ø¶Ø±Ø§Ø¡ (Ø§Ù„Ø¬ÙˆÙƒØ±)
        const tableGeo = new THREE.PlaneGeometry(20, 15);
        const tableMat = new THREE.MeshStandardMaterial({ 
            color: 0x1a5d2e, 
            roughness: 0.8,
            metalness: 0.1
        });
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.rotation.x = -Math.PI / 2;
        scene.add(table);

        // 4. Ø¯Ø§Ù„Ø© Ø¨Ù†Ø§Ø¡ Ø­Ø¬Ø± Ø¯ÙˆÙ…ÙŠÙ†Ùˆ Ø§Ø­ØªØ±Ø§ÙÙŠ
        function createTile(x, z, rotation, valA, valB) {
            const group = new THREE.Group();
            
            // Ø¬Ø³Ù… Ø§Ù„Ø­Ø¬Ø± Ø§Ù„Ø£Ø¨ÙŠØ¶ Ø§Ù„Ù„Ø§Ù…Ø¹
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.25, 2.2),
                new THREE.MeshStandardMaterial({ color: 0xfafafa, roughness: 0.05 })
            );
            group.add(body);

            // Ø§Ù„Ø®Ø· Ø§Ù„Ø£Ø³ÙˆØ¯
            const line = new THREE.Mesh(
                new THREE.PlaneGeometry(1.1, 0.04),
                new THREE.MeshBasicMaterial({ color: 0x333333 })
            );
            line.rotation.x = -Math.PI / 2;
            line.position.y = 0.13;
            group.add(line);

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø· (Pips)
            const dotGeo = new THREE.CircleGeometry(0.12, 12);
            const dotMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            function addDots(val, isTop) {
                const offset = isTop ? 0.5 : -0.5;
                if (val === 1) {
                    const d = new THREE.Mesh(dotGeo, dotMat);
                    d.rotation.x = -Math.PI / 2;
                    d.position.set(0, 0.131, offset);
                    group.add(d);
                }
                // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø­Ø§Ù„Ø§Øª (2,3,4,5,6) Ù‡Ù†Ø§ Ù„Ø§Ø­Ù‚Ø§Ù‹
            }
            
            addDots(1, true); // Ù†Ù‚Ø·Ø© ÙÙˆÙ‚
            addDots(1, false); // Ù†Ù‚Ø·Ø© ØªØ­Øª

            group.position.set(x, 0.1, z);
            group.rotation.y = rotation;
            scene.add(group);
            return group;
        }

        // Ø±Øµ Ø­Ø¬Ø§Ø±Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ© (Ù…Ø«Ù„ Ø§Ù„ØµÙˆØ±Ø©)
        createTile(0, 0, 0, 1, 1);
        createTile(1.5, 0, 0, 1, 1);
        createTile(-1.5, 0, Math.PI/2, 1, 1);

        // 5. Ø§Ù„ØªÙØ§Ø¹Ù„ Ø¨Ø§Ù„Ù„Ù…Ø³ (Touch) Ù„Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„
        let isDragging = false;
        let previousTouchX = 0;

        window.addEventListener('touchstart', (e) => {
            isDragging = true;
            previousTouchX = e.touches[0].pageX;
        });

        window.addEventListener('touchmove', (e) => {
            if (isDragging) {
                const delta = e.touches[0].pageX - previousTouchX;
                scene.rotation.y += delta * 0.01;
                previousTouchX = e.touches[0].pageX;
            }
        });

        window.addEventListener('touchend', () => isDragging = false);

        // Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ«
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Ø¶Ø¨Ø· Ø§Ù„Ù…Ù‚Ø§Ø³ Ø¹Ù†Ø¯ ØªØ¯ÙˆÙŠØ± Ø§Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
