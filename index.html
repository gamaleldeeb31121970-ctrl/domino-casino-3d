<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Domino Pro - 3D Snap</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #031006; touch-action: none; }
        #ui { position: absolute; top: 10px; width: 100%; display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box; pointer-events: none; }
        .pill { background: rgba(0,0,0,0.85); color: #ffcc00; padding: 8px 15px; border-radius: 20px; border: 1.5px solid #ffd700; font-family: sans-serif; font-weight: bold; font-size: 14px; }
        #msg { position: absolute; bottom: 140px; width: 100%; text-align: center; color: white; font-family: sans-serif; text-shadow: 2px 2px 4px #000; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="pill">ğŸ’° 28.5M</div>
        <div class="pill" id="status">Ø§Ø³Ø­Ø¨ Ø­Ø¬Ø± Ù„ØªØ¨Ø¯Ø£</div>
        <div class="pill">ğŸ’¸ 1K</div>
    </div>
    <div id="msg"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 10);
        camera.lookAt(0, -2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const light = new THREE.DirectionalLight(0xffffff, 0.6);
        light.position.set(5, 15, 10);
        scene.add(light);

        // --- Ø§Ù„Ø·Ø§ÙˆÙ„Ø© Ø¨Ø­Ø¯ÙˆØ¯ Ù…Ø­Ø¯Ø¯Ø© ---
        const tableGeo = new THREE.BoxGeometry(20, 0.5, 30);
        const tableMat = new THREE.MeshStandardMaterial({ color: 0x125424 });
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.position.y = -0.25;
        scene.add(table);

        // Ø¨Ø±ÙˆØ§Ø² Ø®Ø´Ø¨
        const borderGeo = new THREE.BoxGeometry(21, 0.6, 31);
        const borderMat = new THREE.MeshStandardMaterial({ color: 0x3d2b1f });
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.position.y = -0.3;
        scene.add(border);

        const T_W = 0.9, T_H = 0.25, T_L = 1.8;
        let playerHand = [], boardTiles = [], selectedTile = null;
        let leftVal = 6, rightVal = 6; 
        let leftX = -T_L/2, rightX = T_L/2;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function create3DTile(x, z, v1, v2, isHand = false) {
            const group = new THREE.Group();
            
            // Ø¬Ø³Ù… Ø§Ù„Ø­Ø¬Ø± Ù…Ø¹ Ø­ÙˆØ§Ù
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(T_W, T_H, T_L),
                new THREE.MeshStandardMaterial({ color: 0xfafafa })
            );
            group.add(body);

            // Ø®Ø· Ø§Ù„ØªÙ‚Ø³ÙŠÙ… ØºØ§Ø¦Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹
            const line = new THREE.Mesh(new THREE.PlaneGeometry(T_W, 0.05), new THREE.MeshBasicMaterial({color: 0x000}));
            line.rotation.x = -Math.PI/2; line.position.y = T_H/2 + 0.001;
            group.add(line);

            // Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø§Ø·
            const dotGeo = new THREE.CircleGeometry(0.08, 12);
            const dotMat = new THREE.MeshBasicMaterial({ color: 0x000 });
            const drawPips = (val, zOffset) => {
                const p = [];
                if(val%2!==0) p.push([0,0]);
                if(val>=2) p.push([0.22, 0.25], [-0.22, -0.25]);
                if(val>=4) p.push([0.22, -0.25], [-0.22, 0.25]);
                if(val===6) p.push([0.22, 0], [-0.22, 0]);
                p.forEach(pos => {
                    const d = new THREE.Mesh(dotGeo, dotMat);
                    d.rotation.x = -Math.PI/2;
                    d.position.set(pos[0], T_H/2 + 0.01, zOffset + pos[1]);
                    group.add(d);
                });
            };
            drawPips(v1, 0.45); drawPips(v2, -0.45);

            group.position.set(x, T_H/2, z);
            group.userData = { v1, v2, isHand, ox: x, oz: z };
            scene.add(group);
            if(isHand) playerHand.push(group);
            return group;
        }

        // ØªÙˆØ²ÙŠØ¹ Ø§Ù„ÙŠØ¯ (7 Ø¨Ù„Ø§Ø·Ø§Øª Ù…ØªÙ„Ø§ØµÙ‚Ø© Ø¨Ø§Ù†ØªØ¸Ø§Ù…)
        for(let i=0; i<7; i++) {
            create3DTile(-3 + (i * 1.0), 8, i, i, true);
        }
        // Ø­Ø¬Ø± Ø§Ù„Ø³Ù†ØªØ±
        create3DTile(0, 0, 6, 6, false);

        // --- Ù…Ù†Ø·Ù‚ Ø§Ù„Ù„Ù…Ø³ ÙˆØ§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£ÙˆØªÙˆÙ…Ø§ØªÙŠÙƒÙŠ ---
        window.addEventListener('touchstart', e => {
            mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hit = raycaster.intersectObjects(playerHand, true);
            if(hit.length > 0) {
                selectedTile = hit[0].object.parent;
                selectedTile.position.y = 1.5;
            }
        });

        window.addEventListener('touchmove', e => {
            if(!selectedTile) return;
            mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const ground = raycaster.intersectObject(table);
            if(ground.length > 0) {
                selectedTile.position.x = ground[0].point.x;
                selectedTile.position.z = ground[0].point.z;
            }
        });

        window.addEventListener('touchend', () => {
            if(!selectedTile) return;
            const distL = selectedTile.position.distanceTo(new THREE.Vector3(leftX, 0, 0));
            const distR = selectedTile.position.distanceTo(new THREE.Vector3(rightX, 0, 0));
            let snapped = false;

            // Ø¥Ø°Ø§ Ø§Ù‚ØªØ±Ø¨ Ø§Ù„Ø­Ø¬Ø± Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ø¨Ù…Ø³Ø§ÙØ© Ø£Ù‚Ù„ Ù…Ù† 3 ÙˆØ­Ø¯Ø§Øª
            if(distR < 3) {
                selectedTile.position.set(rightX + T_L/2, T_H/2, 0);
                selectedTile.rotation.y = Math.PI/2; // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø£ÙˆØªÙˆÙ…Ø§ØªÙŠÙƒ
                rightX += T_L;
                snapped = true;
            } 
            else if(distL < 3) {
                selectedTile.position.set(leftX - T_L/2, T_H/2, 0);
                selectedTile.rotation.y = Math.PI/2;
                leftX -= T_L;
                snapped = true;
            }

            if(snapped) {
                playerHand = playerHand.filter(t => t !== selectedTile);
                selectedTile.userData.isHand = false;
            } else {
                // Ø±Ø¬ÙˆØ¹ Ù„Ù…ÙƒØ§Ù†Ù‡ ÙÙŠ Ø§Ù„ÙŠØ¯
                selectedTile.position.set(selectedTile.userData.ox, T_H/2, selectedTile.userData.oz);
                selectedTile.rotation.y = 0;
            }
            selectedTile.position.y = T_H/2;
            selectedTile = null;
        });

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
    </script>
</body>
</html>
