
<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Domino Ivory Pro - Sound Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; touch-action: none; font-family: sans-serif; }
        #ui { position: absolute; top: 10px; width: 100%; display: flex; justify-content: center; gap: 10px; pointer-events: none; z-index: 10; }
        .pill { background: rgba(0,0,0,0.8); color: #ffd700; padding: 8px 15px; border-radius: 20px; border: 1.5px solid #ffd700; font-weight: bold; font-size: 12px; }
        #msg { position: absolute; bottom: 120px; width: 100%; text-align: center; color: #fff; text-shadow: 2px 2px 4px #000; font-weight: bold; pointer-events: none; font-size: 18px; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="pill">ðŸ’° 28.5M</div>
        <div class="pill" id="status">Ø§Ø¶ØºØ· Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨</div>
        <div class="pill">ðŸ’¸ 1K</div>
    </div>
    <div id="msg">Ø§Ø³ØªÙ…ØªØ¹ Ø¨ØµÙˆØª Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Ù…Ø­Ø±Ùƒ Ø§Ù„ØµÙˆØª Ø§Ù„Ù…ØªÙ‚Ø¯Ù… ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;

            if (type === 'clack') { // ØµÙˆØª Ø®Ø¨Ø·Ø© Ø²Ù„Ø· Ø­Ø§Ø¯Ø©
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square'; // ØµÙˆØª Ø£Ø­Ø¯Ù‘
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.05);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(now + 0.1);
            } else if (type === 'win') { // Ù†ØºÙ…Ø© Ø§Ù„ÙÙˆØ²
                [523, 659, 783, 1046].forEach((f, i) => {
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.frequency.setValueAtTime(f, now + i*0.1);
                    g.gain.setValueAtTime(0.2, now + i*0.1);
                    g.gain.exponentialRampToValueAtTime(0.01, now + i*0.1 + 0.3);
                    o.connect(g); g.connect(audioCtx.destination);
                    o.start(now + i*0.1); o.stop(now + i*0.1 + 0.4);
                });
            } else if (type === 'lose') { // Ù†ØºÙ…Ø© Ø§Ù„Ù‡Ø²ÙŠÙ…Ø©
                [300, 200, 150].forEach((f, i) => {
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.type = 'sawtooth';
                    o.frequency.setValueAtTime(f, now + i*0.2);
                    g.gain.setValueAtTime(0.2, now + i*0.2);
                    g.gain.exponentialRampToValueAtTime(0.01, now + i*0.2 + 0.5);
                    o.connect(g); g.connect(audioCtx.destination);
                    o.start(now + i*0.2); o.stop(now + i*0.2 + 0.6);
                });
            }
        }

        // Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø®Ù„ÙÙŠØ© Ù‡Ø§Ø¯Ø¦Ø© (ØªÙˆÙ„ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ)
        function startMusic() {
            const loop = () => {
                const now = audioCtx.currentTime;
                const notes = [196, 220, 261, 329]; // Ù†ØºÙ…Ø§Øª Ø±Ø§ÙŠÙ‚Ø©
                const f = notes[Math.floor(Math.random()*notes.length)];
                const o = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                o.type = 'sine';
                o.frequency.setValueAtTime(f, now);
                g.gain.setValueAtTime(0.05, now);
                g.gain.exponentialRampToValueAtTime(0.001, now + 2);
                o.connect(g); g.connect(audioCtx.destination);
                o.start(); o.stop(now + 2.5);
                setTimeout(loop, 3000);
            };
            loop();
        }

        // --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„Ù€ 3D ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 22, 16); camera.lookAt(0, -2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const light = new THREE.SpotLight(0xffffff, 1);
        light.position.set(10, 20, 10); light.castShadow = true;
        scene.add(light);

        // Ø§Ù„Ø·Ø§ÙˆÙ„Ø© Ø¨Ø§Ù„Ø¹Ø±Ø¶ ÙˆØ§Ù„Ø¨Ø±ÙˆØ§Ø² Ø§Ù„Ù…Ø­Ù…Ø±
        const table = new THREE.Group();
        const felt = new THREE.Mesh(new THREE.BoxGeometry(30, 0.2, 20), new THREE.MeshStandardMaterial({ color: 0x0a3d16, roughness: 1 }));
        felt.receiveShadow = true; table.add(felt);

        const woodMat = new THREE.MeshStandardMaterial({ color: 0x4a0a0a, roughness: 0.2, metalness: 0.3 }); // Ø£Ø­Ù…Ø± Ø®Ø´Ø¨ÙŠ Ø¯Ø§ÙƒÙ†
        const fL = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 21), woodMat); fL.position.set(-15.5, 0.5, 0);
        const fR = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 21), woodMat); fR.position.set(15.5, 0.5, 0);
        const fT = new THREE.Mesh(new THREE.BoxGeometry(32, 1.2, 1), woodMat); fT.position.set(0, 0.5, -10.5);
        const fB = new THREE.Mesh(new THREE.BoxGeometry(32, 1.2, 1), woodMat); fB.position.set(0, 0.5, 10.5);
        table.add(fL, fR, fT, fB); scene.add(table);

        // --- Ù…ØµÙ†Ø¹ Ø§Ù„Ø­Ø¬Ø§Ø±Ø© ---
        let playerHand = [], leftE = {x: -1.2, val: 6}, rightE = {x: 1.2, val: 6};

        function createTile(v1, v2, x, z, isHand = false) {
            const group = new THREE.Group();
            const shape = new THREE.Shape();
            const w=1, l=2, r=0.2; // Ø­ÙˆØ§Ù Ù†Ø§Ø¹Ù…Ø© Ø¬Ø¯Ø§Ù‹
            shape.moveTo(-w/2+r, -l/2); shape.lineTo(w/2-r, -l/2); shape.absarc(w/2-r, -l/2+r, r, 1.5*Math.PI, 0, false);
            shape.lineTo(w/2, l/2-r); shape.absarc(w/2-r, l/2-r, r, 0, 0.5*Math.PI, false);
            shape.lineTo(-w/2+r, l/2); shape.absarc(-w/2+r, l/2-r, r, 0.5*Math.PI, Math.PI, false);
            shape.lineTo(-w/2, -l/2+r); shape.absarc(-w/2+r, -l/2+r, r, Math.PI, 1.5*Math.PI, false);

            const body = new THREE.Mesh(
                new THREE.ExtrudeGeometry(shape, {depth:0.25, bevelEnabled:true, bevelSegments:12, bevelSize:0.05, bevelThickness:0.05}),
                new THREE.MeshStandardMaterial({ color: 0xfafaf5, roughness: 0.05 }) // Ø¹Ø§Ø¬ÙŠ ÙØ®Ù…
            );
            body.rotation.x = -Math.PI/2; body.castShadow = true; group.add(body);

            // Ø®Ø· Ø§Ù„ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù…Ø­ÙÙˆØ±
            const line = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.02, 0.05), new THREE.MeshBasicMaterial({color: 0x000000}));
            line.position.y = 0.13; group.add(line);

            const pivot = new THREE.Mesh(new THREE.SphereGeometry(0.05, 16, 16), new THREE.MeshStandardMaterial({color:0xffd700, metalness:1}));
            pivot.position.y = 0.14; group.add(pivot);

            const drawPips = (val, zOff) => {
                const g=0.3; let p=[];
                if(val%2!==0) p.push([0,0]); if(val>=2) p.push([g,g], [-g,-g]); if(val>=4) p.push([-g,g], [g,-g]); if(val===6) p.push([g,0], [-g,0]);
                p.forEach(pos => {
                    const d = new THREE.Mesh(new THREE.SphereGeometry(0.1,16,16), new THREE.MeshStandardMaterial({color:0x000}));
                    d.position.set(pos[0], 0.12, zOff+pos[1]); group.add(d);
                });
            };
            drawPips(v1, 0.5); drawPips(v2, -0.5);

            group.position.set(x, 0.15, z);
            group.userData = { v1, v2, isHand, ox: x, oz: z, isD: v1===v2 };
            scene.add(group);
            if(isHand) playerHand.push(group);
            return group;
        }

        // ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ø¬Ø§Ø±Ø©
        for(let i=0; i<7; i++) createTile(i, (i+1)%7, -4.5+(i*1.5), 7, true);
        createTile(6, 6, 0, 0, false);

        // --- Ø§Ù„ØªØ­ÙƒÙ… ÙˆØ§Ù„Ù„Ù…Ø³ ---
        let selected = null;
        const ray = new THREE.Raycaster();
        const m = new THREE.Vector2();

        window.addEventListener('touchstart', e => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
                startMusic(); // Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø¹Ù†Ø¯ Ø£ÙˆÙ„ Ù„Ù…Ø³Ø©
            }
            m.x = (e.touches[0].clientX/window.innerWidth)*2-1; m.y = -(e.touches[0].clientY/window.innerHeight)*2+1;
            ray.setFromCamera(m, camera);
            const hits = ray.intersectObjects(playerHand, true);
            if(hits.length > 0) {
                let obj = hits[0].object; while(obj.parent && !obj.userData.isHand) obj = obj.parent;
                selected = obj; selected.position.y = 1.5;
            }
        });

        window.addEventListener('touchmove', e => {
            if(!selected) return;
            m.x = (e.touches[0].clientX/window.innerWidth)*2-1; m.y = -(e.touches[0].clientY/window.innerHeight)*2+1;
            ray.setFromCamera(m, camera);
            const ground = ray.intersectObject(felt);
            if(ground.length > 0) selected.position.set(ground[0].point.x, 1.2, ground[0].point.z);
        });

        window.addEventListener('touchend', () => {
            if(!selected) return;
            let played = false;
            const p = selected.position;
            if(p.distanceTo(new THREE.Vector3(rightE.x, 0, 0)) < 3.5) { snap(selected, 'right'); played = true; }
            else if(p.distanceTo(new THREE.Vector3(leftE.x, 0, 0)) < 3.5) { snap(selected, 'left'); played = true; }

            if(played) {
                playerHand = playerHand.filter(t => t !== selected);
                playSound('clack'); // ØµÙˆØª Ø§Ù„Ø®Ø¨Ø·Ø© Ø§Ù„Ø­Ø§Ø¯
                document.getElementById('status').innerText = "Ù„Ø¹Ø¨Ø© Ù…Ù…ØªØ§Ø²Ø©!";
                if(playerHand.length === 0) playSound('win');
            } else {
                selected.position.set(selected.userData.ox, 0.15, selected.userData.oz);
            }
            selected.position.y = 0.15; selected = null;
        });

        function snap(tile, side) {
            const isD = tile.userData.isD;
            if(side === 'right') {
                tile.position.set(rightE.x + (isD?0.6:1.1), 0.15, 0);
                tile.rotation.y = isD ? 0 : Math.PI/2;
                rightE.x = tile.position.x + (isD?0.5:1);
            } else {
                tile.position.set(leftE.x - (isD?0.6:1.1), 0.15, 0);
                tile.rotation.y = isD ? 0 : Math.PI/2;
                leftE.x = tile.position.x - (isD?0.5:1);
            }
            tile.userData.isHand = false;
        }

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
    </script>
</body>
</html>
