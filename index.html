<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Domino Pro - Rules Engine</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #031006; font-family: sans-serif; }
        #ui-layer { position: absolute; top: 10px; width: 100%; display: flex; justify-content: space-between; padding: 0 15px; box-sizing: border-box; z-index: 100; pointer-events: none; }
        .pill { background: rgba(0,0,0,0.8); color: #ffcc00; padding: 6px 15px; border-radius: 20px; border: 1px solid #ffd700; font-size: 13px; font-weight: bold; }
        #msg { position: absolute; bottom: 130px; width: 100%; text-align: center; color: #fff; font-size: 14px; text-shadow: 1px 1px 2px #000; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="pill">ğŸ’° 28.5M</div>
        <div id="turn-info" class="pill">Ø¯ÙˆØ±Ùƒ Ø§Ù„Ø¢Ù†</div>
        <div class="pill">ğŸ’¸ 1K</div>
    </div>
    <div id="msg">Ø¶Ø¹ Ø§Ù„Ø­Ø¬Ø± Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚ Ù„Ù„Ø£Ø±Ù‚Ø§Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø§ÙˆÙ„Ø©</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 18, 12);
        camera.lookAt(0, -2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(5, 15, 5);
        scene.add(sun);

        const table = new THREE.Mesh(new THREE.PlaneGeometry(50, 40), new THREE.MeshStandardMaterial({ color: 0x125424 }));
        table.rotation.x = -Math.PI / 2;
        scene.add(table);

        const T_WIDTH = 0.8, T_HEIGHT = 0.18, T_LENGTH = 1.6;
        let playerHand = [], selectedTile = null;
        const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();

        // --- Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ---
        let leftValue = 6, rightValue = 6; // Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø£Ø·Ø±Ø§Ù Ø§Ù„Ù…ÙØªÙˆØ­Ø© (Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© 6-6)
        let leftAnchorX = -T_LENGTH / 2, rightAnchorX = T_LENGTH / 2;

        function createTile(x, z, v1, v2, isHand = false) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(T_WIDTH, T_HEIGHT, T_LENGTH), new THREE.MeshStandardMaterial({ color: 0xfafafa }));
            group.add(body);
            
            const line = new THREE.Mesh(new THREE.PlaneGeometry(T_WIDTH - 0.1, 0.04), new THREE.MeshBasicMaterial({ color: 0x000 }));
            line.rotation.x = -Math.PI/2; line.position.y = T_HEIGHT/2 + 0.01; group.add(line);

            // Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ v1 Ùˆ v2
            const dotGeo = new THREE.CircleGeometry(0.08, 8);
            const dotMat = new THREE.MeshBasicMaterial({ color: 0x000 });
            const addPips = (val, offsetZ) => {
                if(val === 1) {
                    const d = new THREE.Mesh(dotGeo, dotMat); d.rotation.x=-Math.PI/2; d.position.set(0,T_HEIGHT/2+0.012, offsetZ); group.add(d);
                } else if (val > 1) { // ØªØ¨Ø³ÙŠØ· Ù„Ù„Ù†Ù‚Ø§Ø· Ø­Ø§Ù„ÙŠØ§Ù‹
                    for(let i=0; i<2; i++) {
                        const d = new THREE.Mesh(dotGeo, dotMat); d.rotation.x=-Math.PI/2;
                        d.position.set(i===0?0.2:-0.2, T_HEIGHT/2+0.012, offsetZ + (i===0?0.2:-0.2)); group.add(d);
                    }
                }
            };
            addPips(v1, 0.4); addPips(v2, -0.4);

            group.position.set(x, T_HEIGHT/2, z);
            group.userData = { v1, v2, isHand, originalX: x, originalZ: z };
            scene.add(group);
            if(isHand) playerHand.push(group);
            return group;
        }

        // Ø­Ø¬Ø± Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (6-6)
        createTile(0, 0, 6, 6, false);

        // ØªÙˆØ²ÙŠØ¹ ÙŠØ¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ (Ø£Ø±Ù‚Ø§Ù… Ù…ØªÙ†ÙˆØ¹Ø© Ù„Ù„ØªØ¬Ø±Ø¨Ø©)
        const myNumbers = [[6,1], [1,5], [5,5], [6,3], [3,2], [0,0], [4,4]];
        for(let i=0; i<7; i++) {
            createTile(-4 + (i * 1.3), 7, myNumbers[i][0], myNumbers[i][1], true);
        }

        // --- Ù…Ù†Ø·Ù‚ Ø§Ù„Ø³Ø­Ø¨ ÙˆØ§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ ---
        window.addEventListener('touchstart', e => {
            mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(playerHand, true);
            if (intersects.length > 0) {
                selectedTile = intersects[0].object.parent;
                selectedTile.position.y = 1.5;
            }
        });

        window.addEventListener('touchmove', e => {
            if (!selectedTile) return;
            mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersectTable = raycaster.intersectObject(table);
            if (intersectTable.length > 0) {
                selectedTile.position.x = intersectTable[0].point.x;
                selectedTile.position.z = intersectTable[0].point.z;
            }
        });

        window.addEventListener('touchend', () => {
            if (selectedTile) {
                let v1 = selectedTile.userData.v1;
                let v2 = selectedTile.userData.v2;
                let played = false;

                // 1. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø·Ø±Ù Ø§Ù„Ø£ÙŠÙ…Ù†
                if (Math.abs(selectedTile.position.x - rightAnchorX) < 2.5 && Math.abs(selectedTile.position.z) < 2) {
                    if (v1 === rightValue) {
                        selectedTile.rotation.y = Math.PI / 2; // ÙˆØ¶Ø¹ Ø£ÙÙ‚ÙŠ
                        selectedTile.position.set(rightAnchorX + T_LENGTH/2, T_HEIGHT/2, 0);
                        rightValue = v2; played = true;
                    } else if (v2 === rightValue) {
                        selectedTile.rotation.y = -Math.PI / 2; // Ù‚Ù„Ø¨ Ø§Ù„Ø­Ø¬Ø± Ù„ÙŠØ·Ø§Ø¨Ù‚
                        selectedTile.position.set(rightAnchorX + T_LENGTH/2, T_HEIGHT/2, 0);
                        rightValue = v1; played = true;
                    }
                    if(played) rightAnchorX += T_LENGTH;
                }
                // 2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø·Ø±Ù Ø§Ù„Ø£ÙŠØ³Ø±
                else if (Math.abs(selectedTile.position.x - leftAnchorX) < 2.5 && Math.abs(selectedTile.position.z) < 2) {
                    if (v2 === leftValue) {
                        selectedTile.rotation.y = Math.PI / 2;
                        selectedTile.position.set(leftAnchorX - T_LENGTH/2, T_HEIGHT/2, 0);
                        leftValue = v1; played = true;
                    } else if (v1 === leftValue) {
                        selectedTile.rotation.y = -Math.PI / 2;
                        selectedTile.position.set(leftAnchorX - T_LENGTH/2, T_HEIGHT/2, 0);
                        leftValue = v2; played = true;
                    }
                    if(played) leftAnchorX -= T_LENGTH;
                }

                if (played) {
                    selectedTile.userData.isHand = false;
                    playerHand = playerHand.filter(t => t !== selectedTile);
                    document.getElementById('msg').innerText = "Ø­Ø±ÙƒØ© ØµØ­ÙŠØ­Ø©! Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ø§Ù„Ø¢Ù†: " + leftValue + " Ø£Ùˆ " + rightValue;
                } else {
                    // Ø±Ø¬ÙˆØ¹ Ù„Ùˆ Ø§Ù„Ø­Ø±ÙƒØ© ØºÙ„Ø·
                    selectedTile.position.set(selectedTile.userData.originalX, T_HEIGHT/2, selectedTile.userData.originalZ);
                    selectedTile.rotation.y = 0;
                    document.getElementById('msg').innerText = "Ø®Ø·Ø£! Ø§Ù„Ø±Ù‚Ù… Ù„Ø§ ÙŠØ·Ø§Ø¨Ù‚ Ø§Ù„Ø£Ø·Ø±Ø§Ù";
                }
                selectedTile = null;
            }
        });

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
    </script>
</body>
</html>
