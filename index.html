<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Domino Casino Royale 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #011607; touch-action: none; font-family: 'Arial', sans-serif; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        .player-info { position: absolute; background: linear-gradient(145deg, #1a1a1a, #000); color: #ffd700; padding: 10px 20px; border: 2px solid #ffd700; border-radius: 50px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 15px rgba(0,0,0,0.6); }
        #msg-bar { position: absolute; bottom: 15%; width: 100%; text-align: center; color: #fff; font-size: 18px; font-weight: bold; text-shadow: 0 2px 5px #000; letter-spacing: 1px; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="player-info" style="top: 20px; right: 20px;">الخصم: <span id="ai-count">7</span></div>
        <div class="player-info" style="top: 20px; left: 20px;">أنت: <span id="p-count">7</span></div>
        <div id="msg-bar">اسحب الحجر وضعه في مكانه الصحيح</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- إعداد المحرك والبيئة ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x011607);
        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 14, 10); camera.lookAt(0, -2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // إضاءة الاستوديو
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 15, 7); dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- الطاولة الفخمة ---
        const tableGeo = new THREE.BoxGeometry(40, 0.5, 30);
        const tableMat = new THREE.MeshStandardMaterial({ color: 0x0a3d16, roughness: 0.9, metalness: 0.1 });
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.receiveShadow = true; table.position.y = -0.25; scene.add(table);

        // برواز خشبي محيط
        const frameMat = new THREE.MeshStandardMaterial({ color: 0x2b0505, roughness: 0.2, metalness: 0.4 });
        const frame1 = new THREE.Mesh(new THREE.BoxGeometry(41, 1.2, 1), frameMat); frame1.position.set(0, 0, 15); scene.add(frame1);
        const frame2 = new THREE.Mesh(new THREE.BoxGeometry(41, 1.2, 1), frameMat); frame2.position.set(0, 0, -15); scene.add(frame2);

        // --- نظام الحجارة الملكي ---
        let playerHand = [], aiHand = [], edges = { l: {x: -1.25, v: 6}, r: {x: 1.25, v: 6} };

        function createPremiumTile(v1, v2, x, z, owner) {
            const group = new THREE.Group();
            
            // جسم الحجر (سمك عالي + حواف مشطوفة)
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.6, 2.4),
                new THREE.MeshStandardMaterial({ color: 0xfdfdf5, roughness: 0.03, metalness: 0.05 })
            );
            body.castShadow = true; group.add(body);

            // مسمار السنتر (ذهبي بارز)
            const pivot = new THREE.Mesh(
                new THREE.SphereGeometry(0.09, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 1, roughness: 0.1 })
            );
            pivot.position.y = 0.31; group.add(pivot);

            // خط التقسيم الأسود الغائر
            const line = new THREE.Mesh(new THREE.BoxGeometry(1.15, 0.03, 0.05), new THREE.MeshBasicMaterial({color: 0x000}));
            line.position.y = 0.31; group.add(line);

            // رسم النقاط (محفورة كروياً)
            const drawPips = (val, zOff) => {
                const g = 0.38; let pts = [];
                if(val % 2 !== 0) pts.push([0, 0]);
                if(val >= 2) pts.push([g, g], [-g, -g]);
                if(val >= 4) pts.push([-g, g], [g, -g]);
                if(val === 6) pts.push([g, 0], [-g, 0]);

                pts.forEach(p => {
                    const pip = new THREE.Mesh(
                        new THREE.SphereGeometry(0.11, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4 })
                    );
                    pip.position.set(p[0], 0.28, zOff + p[1]); 
                    group.add(pip);
                });
            };

            if(owner !== 'ai') { drawPips(v1, 0.6); drawPips(v2, -0.6); }
            else { group.rotation.x = Math.PI; } // مقلوب للخصم

            group.position.set(x, 0.3, z);
            group.userData = { v1, v2, owner, ox: x, oz: z, isD: v1 === v2 };
            scene.add(group);
            return group;
        }

        // توزيع "الرصة المتلاحمة"
        const pool = []; for(let i=0; i<=6; i++) for(let j=i; j<=6; j++) pool.push([i,j]);
        pool.sort(() => Math.random() - 0.5);
        
        // تقليل المسافة لـ 1.25 عشان يبقوا "لزق"
        for(let i=0; i<7; i++) playerHand.push(createPremiumTile(...pool.pop(), -3.8 + (i * 1.27), 8, 'p'));
        for(let i=0; i<7; i++) aiHand.push(createPremiumTile(...pool.pop(), -3.8 + (i * 1.27), -8, 'ai'));
        createPremiumTile(6, 6, 0, 0, 'board');

        // --- التحكم واللمس ---
        let selected = null; const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();

        window.addEventListener('touchstart', e => {
            const t = e.touches[0];
            mouse.x = (t.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(t.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(playerHand, true);
            if(hits.length > 0) {
                let obj = hits[0].object; while(obj.parent && obj.userData.owner !== 'p') obj = obj.parent;
                selected = obj; selected.position.y = 1.2;
            }
        });

        window.addEventListener('touchmove', e => {
            if(!selected) return;
            const t = e.touches[0];
            mouse.x = (t.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(t.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const groundHit = raycaster.intersectObject(table);
            if(groundHit.length > 0) selected.position.set(groundHit[0].point.x, 0.8, groundHit[0].point.z);
        });

        window.addEventListener('touchend', () => {
            if(!selected) return;
            let played = false; const pos = selected.position;
            // مسافة الالتحام (Snap)
            if(pos.distanceTo(new THREE.Vector3(edges.r.x, 0, 0)) < 3) { snapTile(selected, 'r'); played = true; }
            else if(pos.distanceTo(new THREE.Vector3(edges.l.x, 0, 0)) < 3) { snapTile(selected, 'l'); played = true; }

            if(played) {
                playerHand = playerHand.filter(t => t !== selected);
                document.getElementById('p-count').innerText = playerHand.length;
                setTimeout(aiMove, 1200);
            } else {
                selected.position.set(selected.userData.ox, 0.3, selected.userData.oz);
            }
            selected.position.y = 0.3; selected = null;
        });

        function aiMove() {
            let idx = aiHand.findIndex(t => t.userData.v1 === edges.l.v || t.userData.v2 === edges.l.v || t.userData.v1 === edges.r.v || t.userData.v2 === edges.r.v);
            if(idx !== -1) {
                let t = aiHand[idx]; t.rotation.x = 0;
                // إظهار النقاط
                const show = (v, zO) => {
                    const g = 0.38; let pts = [];
                    if(v%2!==0) pts.push([0,0]); if(v>=2) pts.push([g,g], [-g,-g]); if(v>=4) pts.push([-g,g], [g,-g]); if(v===6) pts.push([g,0], [-g,0]);
                    pts.forEach(p => {
                        const pip = new THREE.Mesh(new THREE.SphereGeometry(0.11, 16, 16), new THREE.MeshStandardMaterial({color:0x111111}));
                        pip.position.set(p[0], 0.28, zO + p[1]); t.add(pip);
                    });
                };
                show(t.userData.v1, 0.6); show(t.userData.v2, -0.6);
                if(t.userData.v1 === edges.r.v || t.userData.v2 === edges.r.v) snapTile(t, 'r'); else snapTile(t, 'l');
                aiHand.splice(idx, 1); document.getElementById('ai-count').innerText = aiHand.length;
            }
        }

        function snapTile(t, side) {
            const isD = t.userData.isD; const target = edges[side];
            // تلاحم كلي (بدون أي فراغ)
            t.position.set(side==='r' ? target.x+(isD?0.6:1.2) : target.x-(isD?0.6:1.2), 0.3, 0);
            t.rotation.y = isD ? 0 : Math.PI/2;
            target.v = (t.userData.v1 === target.v) ? t.userData.v2 : t.userData.v1;
            target.x = t.position.x + (side==='r' ? (isD?0.6:1.2) : (isD?-0.6:-1.2));
            t.userData.owner = 'board';
        }

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
