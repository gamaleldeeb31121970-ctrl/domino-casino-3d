<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Domino Master AI - Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #010502; touch-action: none; font-family: sans-serif; }
        #ui { position: absolute; top: 15px; width: 100%; display: flex; justify-content: space-between; padding: 0 25px; box-sizing: border-box; pointer-events: none; z-index: 10; }
        .pill { background: rgba(0,0,0,0.8); color: #ffd700; padding: 10px 18px; border-radius: 25px; border: 2px solid #ffd700; font-weight: bold; font-size: 14px; }
        #msg { position: absolute; bottom: 150px; width: 100%; text-align: center; color: #fff; text-shadow: 2px 2px 5px #000; font-weight: bold; pointer-events: none; font-size: 18px; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="pill">ðŸ’° 28.5M</div>
        <div class="pill" id="status">Ø¯ÙˆØ±Ùƒ Ø§Ù„Ø¢Ù†</div>
        <div class="pill">ðŸ’¸ 1K</div>
    </div>
    <div id="msg">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨ Ø¨Ø³Ø­Ø¨ Ø£ÙˆÙ„ Ø­Ø¬Ø±</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Ù†Ø¸Ø§Ù… Ø§Ù„ØµÙˆØª Ø§Ù„Ù…Ø·ÙˆØ± ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(freq, type, duration, vol) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        }

        const sounds = {
            play: () => playTone(150, 'triangle', 0.1, 0.3), // Ø®Ø¨Ø·Ø© Ø§Ù„Ø­Ø¬Ø±
            win: () => { [440, 554, 659].forEach((f, i) => setTimeout(() => playTone(f, 'sine', 0.4, 0.2), i*150)) },
            lose: () => { [300, 250, 200].forEach((f, i) => setTimeout(() => playTone(f, 'sawtooth', 0.6, 0.2), i*200)) },
            draw: () => playTone(100, 'square', 0.2, 0.1) // Ø³Ø­Ø¨ Ø­Ø¬Ø±
        };

        // --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø´Ù‡Ø¯ ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 25, 18); camera.lookAt(0, -3, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(5, 20, 10); light.castShadow = true;
        scene.add(light);

        // --- Ø§Ù„Ø·Ø§ÙˆÙ„Ø© ÙˆØ§Ù„Ø¨Ø±ÙˆØ§Ø² ---
        const table = new THREE.Group();
        const felt = new THREE.Mesh(new THREE.BoxGeometry(20, 0.2, 30), new THREE.MeshStandardMaterial({ color: 0x0a3d16 }));
        felt.receiveShadow = true; table.add(felt);
        const frameMat = new THREE.MeshStandardMaterial({ color: 0x2b1d0e });
        const f1 = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 31), frameMat); f1.position.set(-10.5, 0.3, 0);
        const f2 = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 31), frameMat); f2.position.set(10.5, 0.3, 0);
        table.add(f1, f2); scene.add(table);

        // --- Ù…Ù†Ø·Ù‚ Ø§Ù„Ù„Ø¹Ø¨Ø© ---
        let playerHand = [], aiHand = [], pool = [];
        let leftEdge = { x: -1.1, val: 6 }, rightEdge = { x: 1.1, val: 6 };
        let isPlayerTurn = true;

        function createTile(v1, v2, x, z, owner) {
            const group = new THREE.Group();
            const shape = new THREE.Shape();
            const w=1, l=2, r=0.15;
            shape.moveTo(-w/2+r, -l/2); shape.lineTo(w/2-r, -l/2); shape.absarc(w/2-r, -l/2+r, r, 1.5*Math.PI, 0, false);
            shape.lineTo(w/2, l/2-r); shape.absarc(w/2-r, l/2-r, r, 0, 0.5*Math.PI, false);
            shape.lineTo(-w/2+r, l/2); shape.absarc(-w/2+r, l/2-r, r, 0.5*Math.PI, Math.PI, false);
            shape.lineTo(-w/2, -l/2+r); shape.absarc(-w/2+r, -l/2+r, r, Math.PI, 1.5*Math.PI, false);

            const body = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, {depth:0.25, bevelEnabled:true, bevelSegments:8, bevelSize:0.05, bevelThickness:0.05}), new THREE.MeshStandardMaterial({ color: owner==='ai'?0x222222:0xfafafa }));
            body.rotation.x = -Math.PI/2; body.castShadow = true; group.add(body);
            
            const pivot = new THREE.Mesh(new THREE.SphereGeometry(0.04, 16, 16), new THREE.MeshStandardMaterial({color:0xffd700}));
            pivot.position.y = 0.15; group.add(pivot);

            if(owner !== 'ai') { // Ù†Ù‚Ø§Ø· Ø§Ù„Ø®ØµÙ… Ù…Ø®ÙÙŠØ©
                const drawPips = (val, zOff) => {
                    const g=0.3; let p=[];
                    if(val%2!==0) p.push([0,0]); if(val>=2) p.push([g,g], [-g,-g]); if(val>=4) p.push([-g,g], [g,-g]); if(val===6) p.push([g,0], [-g,0]);
                    p.forEach(pos => {
                        const d = new THREE.Mesh(new THREE.SphereGeometry(0.08,16,16), new THREE.MeshStandardMaterial({color:0x000}));
                        d.position.set(pos[0], 0.13, zOff+pos[1]); group.add(d);
                    });
                };
                drawPips(v1, 0.5); drawPips(v2, -0.5);
            }

            group.position.set(x, 0.15, z);
            group.userData = { v1, v2, owner, ox: x, oz: z, isDouble: v1===v2 };
            scene.add(group);
            return group;
        }

        // ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ø¬Ø§Ø±Ø©
        function setupGame() {
            let allTiles = [];
            for(let i=0; i<=6; i++) for(let j=i; j<=6; j++) allTiles.push([i,j]);
            allTiles.sort(() => Math.random() - 0.5);

            for(let i=0; i<7; i++) playerHand.push(createTile(...allTiles.pop(), -4+(i*1.3), 10, 'player'));
            for(let i=0; i<7; i++) aiHand.push(createTile(...allTiles.pop(), -4+(i*1.3), -10, 'ai'));
            createTile(6, 6, 0, 0, 'board'); // Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
        }
        setupGame();

        // --- Ø­Ø±ÙƒØ© Ø§Ù„Ø®ØµÙ… (AI) ---
        function aiPlay() {
            if(isPlayerTurn) return;
            document.getElementById('status').innerText = "Ø§Ù„Ø®ØµÙ… ÙŠÙÙƒØ±...";
            
            setTimeout(() => {
                let playableIdx = aiHand.findIndex(t => t.userData.v1 === leftEdge.val || t.userData.v2 === leftEdge.val || t.userData.v1 === rightEdge.val || t.userData.v2 === rightEdge.val);
                
                if(playableIdx !== -1) {
                    let tile = aiHand[playableIdx];
                    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¬Ù‡Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©
                    if(tile.userData.v1 === rightEdge.val || tile.userData.v2 === rightEdge.val) snapTile(tile, 'right');
                    else snapTile(tile, 'left');
                    
                    aiHand.splice(playableIdx, 1);
                    sounds.play();
                    checkWin();
                    isPlayerTurn = true;
                    document.getElementById('status').innerText = "Ø¯ÙˆØ±Ùƒ Ø§Ù„Ø¢Ù†";
                } else {
                    document.getElementById('msg').innerText = "Ø§Ù„Ø®ØµÙ… Ù„Ø§ ÙŠÙ…Ù„Ùƒ Ø­Ø¬Ø±Ù‹Ø§ØŒ Ø¯ÙˆØ±Ùƒ!";
                    isPlayerTurn = true;
                }
            }, 1500);
        }

        function checkWin() {
            if(playerHand.length === 0) { sounds.win(); document.getElementById('msg').innerText = "Ù…Ø¨Ø±ÙˆÙƒ! Ù„Ù‚Ø¯ ÙØ²Øª ðŸ†"; }
            if(aiHand.length === 0) { sounds.lose(); document.getElementById('msg').innerText = "Ù„Ù„Ø£Ø³ÙØŒ Ø§Ù„Ø®ØµÙ… ÙØ§Ø² ðŸ’€"; }
        }

        // --- Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø³Ø­Ø¨ ---
        let selectedTile = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('touchstart', e => {
            if(!isPlayerTurn) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            mouse.x = (e.touches[0].clientX/window.innerWidth)*2-1; mouse.y = -(e.touches[0].clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(playerHand, true);
            if(hits.length > 0) {
                let obj = hits[0].object; while(obj.parent && obj.userData.owner!=='player') obj = obj.parent;
                selectedTile = obj; selectedTile.position.y = 1.5;
            }
        });

        window.addEventListener('touchmove', e => {
            if(!selectedTile) return;
            mouse.x = (e.touches[0].clientX/window.innerWidth)*2-1; mouse.y = -(e.touches[0].clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(mouse, camera);
            const ground = raycaster.intersectObject(felt);
            if(ground.length > 0) selectedTile.position.set(ground[0].point.x, 1.2, ground[0].point.z);
        });

        window.addEventListener('touchend', () => {
            if(!selectedTile) return;
            let played = false;
            const pos = selectedTile.position;
            if(pos.distanceTo(new THREE.Vector3(rightEdge.x, 0, 0)) < 3.5) { snapTile(selectedTile, 'right'); played = true; }
            else if(pos.distanceTo(new THREE.Vector3(leftEdge.x, 0, 0)) < 3.5) { snapTile(selectedTile, 'left'); played = true; }

            if(played) {
                playerHand = playerHand.filter(t => t !== selectedTile);
                sounds.play();
                checkWin();
                isPlayerTurn = false;
                aiPlay();
            } else {
                selectedTile.position.set(selectedTile.userData.ox, 0.15, selectedTile.userData.oz);
            }
            selectedTile.position.y = 0.15; selectedTile = null;
        });

        function snapTile(tile, side) {
            const isD = tile.userData.isDouble;
            if(side === 'right') {
                tile.position.set(rightEdge.x + (isD?0.6:1.05), 0.15, 0);
                tile.rotation.y = isD?0:Math.PI/2;
                rightEdge.val = (tile.userData.v1 === rightEdge.val) ? tile.userData.v2 : tile.userData.v1;
                rightEdge.x = tile.position.x + (isD?0.5:1.0);
            } else {
                tile.position.set(leftEdge.x - (isD?0.6:1.05), 0.15, 0);
                tile.rotation.y = isD?0:Math.PI/2;
                leftEdge.val = (tile.userData.v1 === leftEdge.val) ? tile.userData.v2 : tile.userData.v1;
                leftEdge.x = tile.position.x - (isD?0.5:1.0);
            }
        }

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
    </script>
</body>
</html>
