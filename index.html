
<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Domino Elite - Final Build</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020a04; touch-action: none; font-family: sans-serif; }
        #ui { position: absolute; top: 15px; width: 100%; display: flex; justify-content: space-between; padding: 0 25px; box-sizing: border-box; pointer-events: none; z-index: 10; }
        .pill { background: linear-gradient(180deg, #2c3e50, #000); color: #ffd700; padding: 10px 18px; border-radius: 25px; border: 2px solid #ffd700; font-weight: bold; font-size: 14px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        #msg { position: absolute; bottom: 150px; width: 100%; text-align: center; color: #fff; text-shadow: 2px 2px 5px #000; font-weight: bold; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="pill">ðŸ’° 28.5M</div>
        <div class="pill" id="status">Ø¯ÙˆØ±Ùƒ Ø§Ù„Ø¢Ù†</div>
        <div class="pill">ðŸ’¸ 1K</div>
    </div>
    <div id="msg">Ø§Ø³Ø­Ø¨ Ø­Ø¬Ø±Ù‹Ø§ Ù„Ù„Ø¹Ø¨</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 22, 14); camera.lookAt(0, -3, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 0.7);
        sun.position.set(5, 20, 10); sun.castShadow = true;
        scene.add(sun);

        // Ø§Ù„Ø·Ø§ÙˆÙ„Ø© Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©
        const tableGeo = new THREE.BoxGeometry(22, 0.5, 32);
        const tableMat = new THREE.MeshStandardMaterial({ color: 0x1a5e20 });
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.position.y = -0.25; table.receiveShadow = true;
        scene.add(table);

        const T_W = 1.0, T_H = 0.3, T_L = 2.0;
        let playerHand = [], selectedTile = null;
        let leftX = -1.0, rightX = 1.0; 
        let leftVal = 6, rightVal = 6;

        function createTile(v1, v2, x, z, isHand = false) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(T_W, T_H, T_L), new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 }));
            body.castShadow = true; group.add(body);

            const line = new THREE.Mesh(new THREE.PlaneGeometry(T_W, 0.05), new THREE.MeshBasicMaterial({ color: 0x000 }));
            line.rotation.x = -Math.PI/2; line.position.y = T_H/2 + 0.01; group.add(line);

            const dotGeo = new THREE.SphereGeometry(0.1, 12, 12);
            const dotMat = new THREE.MeshBasicMaterial({ color: 0x000 });
            const drawPips = (val, offsetZ) => {
                const p = [];
                if(val%2!==0) p.push([0,0]);
                if(val>=2) p.push([0.25, 0.3], [-0.25, -0.3]);
                if(val>=4) p.push([0.25, -0.3], [-0.25, 0.3]);
                if(val===6) p.push([0.25, 0], [-0.25, 0]);
                p.forEach(pos => {
                    const d = new THREE.Mesh(dotGeo, dotMat);
                    d.position.set(pos[0], T_H/2 + 0.02, offsetZ + pos[1]);
                    group.add(d);
                });
            };
            drawPips(v1, 0.5); drawPips(v2, -0.5);

            group.position.set(x, T_H/2, z);
            group.userData = { v1, v2, isHand, ox: x, oz: z };
            scene.add(group);
            if(isHand) playerHand.push(group);
            return group;
        }

        // ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ø¬Ø§Ø±Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±
        const handData = [[1,6], [2,6], [3,6], [4,6], [0,6], [5,6], [6,6]];
        handData.forEach((d, i) => createTile(d[0], d[1], -4 + (i*1.3), 8, true));
        
        // Ø­Ø¬Ø± Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
        createTile(6, 6, 0, 0, false);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('touchstart', e => {
            mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(playerHand, true);
            if(hits.length > 0) {
                let obj = hits[0].object; while(obj.parent && !obj.userData.isHand) obj = obj.parent;
                selectedTile = obj; selectedTile.position.y = 1.5;
            }
        });

        window.addEventListener('touchmove', e => {
            if(!selectedTile) return;
            mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersect = raycaster.intersectObject(table);
            if(intersect.length > 0) {
                selectedTile.position.set(intersect[0].point.x, 1.2, intersect[0].point.z);
            }
        });

        window.addEventListener('touchend', () => {
            if(!selectedTile) return;
            let v1 = selectedTile.userData.v1, v2 = selectedTile.userData.v2;
            let played = false;

            // Ù…ØºÙ†Ø§Ø·ÙŠØ³ Ø§Ù„ÙŠÙ…ÙŠÙ†
            if(selectedTile.position.distanceTo(new THREE.Vector3(rightX, 0, 0)) < 3.5) {
                if(v1 === rightVal || v2 === rightVal) {
                    selectedTile.position.set(rightX + T_L/2, T_H/2, 0);
                    selectedTile.rotation.y = Math.PI/2;
                    rightVal = (v1 === rightVal) ? v2 : v1;
                    rightX += T_L; played = true;
                }
            } 
            // Ù…ØºÙ†Ø§Ø·ÙŠØ³ Ø§Ù„ÙŠØ³Ø§Ø±
            else if(selectedTile.position.distanceTo(new THREE.Vector3(leftX, 0, 0)) < 3.5) {
                if(v1 === leftVal || v2 === leftVal) {
                    selectedTile.position.set(leftX - T_L/2, T_H/2, 0);
                    selectedTile.rotation.y = Math.PI/2;
                    leftVal = (v2 === leftVal) ? v1 : v2;
                    leftX -= T_L; played = true;
                }
            }

            if(played) {
                playerHand = playerHand.filter(t => t !== selectedTile);
                selectedTile.userData.isHand = false;
                document.getElementById('msg').innerText = "ØªÙ… ÙˆØ¶Ø¹ Ø§Ù„Ø­Ø¬Ø± Ø¨Ù†Ø¬Ø§Ø­!";
            } else {
                selectedTile.position.set(selectedTile.userData.ox, T_H/2, selectedTile.userData.oz);
                selectedTile.rotation.y = 0;
            }
            selectedTile = null;
        });

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
    </script>
</body>
</html>
