
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Domino Masterpiece 3D</title>
    <style>
        /* CSS مدمج بالكامل لضمان أفضل أداء وتوافق */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #011607; /* خلفية خضرا غامقة زي طاولة القمار */
            touch-action: none; /* لمنع مشاكل اللمس والتكبير التلقائي */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none; /* منع تحديد النص */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* عشان ما تعطلش التفاعل مع الـ 3D */
            z-index: 100;
        }
        .player-info {
            position: absolute;
            background: linear-gradient(145deg, #1a1a1a, #000); /* تصميم أنيق */
            color: #ffd700; /* لون ذهبي */
            padding: 10px 20px;
            border: 2px solid #ffd700;
            border-radius: 50px; /* شكل دائري */
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            pointer-events: auto; /* عشان يقدر المستخدم يتفاعل معاه لو حابب */
            min-width: 60px; /* عشان النص ما يلزقش */
            text-align: center;
        }
        #msg-bar {
            position: absolute;
            bottom: 15%; /* مكان مناسب عشان ما يغطي على الحجارة */
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 2px 5px #000; /* ظل عشان النص يبان واضح */
            letter-spacing: 1px; /* مسافات بين الحروف */
        }
        #draw-btn {
            position: absolute;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, #4CAF50, #2E8B57); /* زر أخضر جذاب */
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: background 0.3s ease;
            pointer-events: auto;
            display: none; /* مخفي في البداية */
        }
        #draw-btn:hover {
            background: linear-gradient(145deg, #388E3C, #1E7B4C);
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="player-info" style="top: 20px; right: 20px;">الخصم: <span id="ai-count">7</span></div>
        <div class="player-info" style="top: 20px; left: 20px;">أنت: <span id="p-count">7</span></div>
        <div id="msg-bar">جاري بدء اللعبة...</div>
        <button id="draw-btn">اسحب من البنك</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- إعداد المحرك والبيئة 3D ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x011607); // لون خلفية الطاولة

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 14, 10); // زاوية كاميرا علوية لإظهار الطاولة والحجارة
        camera.lookAt(0, -2, 0); // تركيز الكاميرا على منتصف الطاولة

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // تحسين الجودة على الشاشات عالية الكثافة
        renderer.shadowMap.enabled = true; // تفعيل الظلال
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ظلال ناعمة
        document.body.appendChild(renderer.domElement);

        // إضاءة احترافية (HemisphereLight للإضاءة العامة، DirectionalLight للظلال)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 15, 7);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024; // جودة الظلال
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- الطاولة الفخمة ببرواز خشبي ---
        const tableGeo = new THREE.BoxGeometry(40, 0.5, 30);
        const tableMat = new THREE.MeshStandardMaterial({ color: 0x0a3d16, roughness: 0.9, metalness: 0.1 });
        const table = new THREE.Mesh(tableGeo, tableMat);
        table.receiveShadow = true;
        table.position.y = -0.25;
        scene.add(table);

        // برواز خشبي أنيق حول الطاولة
        const frameMat = new THREE.MeshStandardMaterial({ color: 0x2b0505, roughness: 0.2, metalness: 0.4 });
        const frame1 = new THREE.Mesh(new THREE.BoxGeometry(41, 1.2, 1), frameMat); frame1.position.set(0, 0, 15); scene.add(frame1);
        const frame2 = new THREE.Mesh(new THREE.BoxGeometry(41, 1.2, 1), frameMat); frame2.position.set(0, 0, -15); scene.add(frame2);
        const frame3 = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 31), frameMat); frame3.position.set(20, 0, 0); scene.add(frame3);
        const frame4 = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 31), frameMat); frame4.position.set(-20, 0, 0); scene.add(frame4);


        // --- نظام الحجارة الملكي (تفاصيل دقيقة) ---
        let playerHand = [], aiHand = [], boardTiles = [], bankPool = []; // إضافة bankPool
        let edges = { l: {x: -1.25, v: 6}, r: {x: 1.25, v: 6} }; // نقاط الالتحام على الطاولة
        let currentPlayer = 'p'; // مين دوره يلعب

        function createPremiumTile(v1, v2, x, z, owner, hidden = false) {
            const group = new THREE.Group();
            
            // جسم الحجر (سمك عالي + حواف مشطوفة)
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.6, 2.4),
                new THREE.MeshStandardMaterial({ color: 0xfdfdf5, roughness: 0.03, metalness: 0.05 })
            );
            body.castShadow = true; group.add(body);

            // مسمار السنتر (ذهبي بارز)
            const pivot = new THREE.Mesh(
                new THREE.SphereGeometry(0.09, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 1, roughness: 0.1 })
            );
            pivot.position.y = 0.31; group.add(pivot);

            // خط التقسيم الأسود الغائر
            const line = new THREE.Mesh(new THREE.BoxGeometry(1.15, 0.03, 0.05), new THREE.MeshBasicMaterial({color: 0x000}));
            line.position.y = 0.31; group.add(line);

            // رسم النقاط (محفورة كروياً)
            const drawPips = (val, zOff) => {
                const g = 0.38; let pts = [];
                if(val % 2 !== 0) pts.push([0, 0]);
                if(val >= 2) pts.push([g, g], [-g, -g]);
                if(val >= 4) pts.push([-g, g], [g, -g]);
                if(val === 6) pts.push([g, 0], [-g, 0]);

                pts.forEach(p => {
                    const pip = new THREE.Mesh(
                        new THREE.SphereGeometry(0.11, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4 })
                    );
                    pip.position.set(p[0], 0.28, zOff + p[1]);
                    group.add(pip);
                });
            };

            if(!hidden) { // لو مش مخفي (للخصم أو للبنك) نظهر النقاط
                drawPips(v1, 0.6);
                drawPips(v2, -0.6);
            } else { // لو مخفي نقلبه
                group.rotation.x = Math.PI;
            }

            group.position.set(x, 0.3, z);
            group.userData = { v1, v2, owner, ox: x, oz: z, isD: v1 === v2, type: 'tile' };
            scene.add(group);
            return group;
        }

        // --- تهيئة اللعبة وتوزيع الحجارة ---
        function initializeGame() {
            let fullPool = [];
            for(let i=0; i<=6; i++) for(let j=i; j<=6; j++) fullPool.push([i,j]);
            fullPool.sort(() => Math.random() - 0.5); // خلط الحجارة

            // توزيع 7 حجارة لكل لاعب
            for(let i=0; i<7; i++) playerHand.push(createPremiumTile(...fullPool.pop(), -3.8 + (i * 1.27), 8, 'p'));
            for(let i=0; i<7; i++) aiHand.push(createPremiumTile(...fullPool.pop(), -3.8 + (i * 1.27), -8, 'ai', true)); // حجارة الخصم مخفية

            // الحجر الأول على الطاولة (هنا افترضنا الدوبل 6)
            const firstTile = createPremiumTile(6, 6, 0, 0, 'board');
            boardTiles.push(firstTile);
            edges.l = {x: -1.25, v: 6};
            edges.r = {x: 1.25, v: 6};

            // باقي الحجارة في البنك
            for(let i = 0; i < fullPool.length; i++) {
                bankPool.push(createPremiumTile(...fullPool[i], -18 + (i * 1.5), 0, 'bank', true)); // مخفية على جنب
            }

            updateCounts();
            document.getElementById('msg-bar').innerText = "دورك الآن: اسحب حجر للعب";
            currentPlayer = 'p'; // اللاعب يبدأ
            checkPlayerMoves();
        }

        function updateCounts() {
            document.getElementById('p-count').innerText = playerHand.length;
            document.getElementById('ai-count').innerText = aiHand.length;
        }

        // --- التحكم واللمس ---
        let selected = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const drawButton = document.getElementById('draw-btn');

        window.addEventListener('touchstart', e => {
            if (currentPlayer !== 'p') return; // فقط لو دور اللاعب

            const t = e.touches[0];
            mouse.x = (t.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(t.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // لو اللاعب لمس زرار "اسحب من البنك"
            const intersects = raycaster.intersectObject(renderer.domElement); // فحص الأزرار في الـ UI
            if (intersects.length > 0 && intersects[0].object === drawButton) {
                // ده فحص وهمي لأن زرار الـ UI مش 3D Object
                // المفروض هنا يتم التعامل مع الـ HTML Button click event
                return;
            }

            const hits = raycaster.intersectObjects(playerHand, true); // فحص حجارة اللاعب
            if(hits.length > 0) {
                let obj = hits[0].object;
                while(obj.parent && obj.userData.owner !== 'p') obj = obj.parent; // نرجع للجسم الرئيسي للحجر
                selected = obj;
                selected.position.y = 1.2; // نرفع الحجر عشان يبان إنه اتحدد
            }
        });

        window.addEventListener('touchmove', e => {
            if(!selected) return;
            const t = e.touches[0];
            mouse.x = (t.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(t.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const groundHit = raycaster.intersectObject(table); // نشوف مكان لمس الطاولة
            if(groundHit.length > 0) {
                selected.position.set(groundHit[0].point.x, 0.8, groundHit[0].point.z); // نحرك الحجر
            }
        });

        window.addEventListener('touchend', () => {
            if(!selected) return;

            let played = false;
            const pos = selected.position;

            // منطق الالتحام والمطابقة
            let matched = false;
            let targetSide = null;

            if (selected.userData.v1 === edges.r.v || selected.userData.v2 === edges.r.v) {
                matched = true;
                targetSide = 'r';
            }
            if (selected.userData.v1 === edges.l.v || selected.userData.v2 === edges.l.v) {
                if (matched) { // لو ينفع يلعب ناحيتين، نخليه يختار الأقرب
                     if (pos.distanceTo(new THREE.Vector3(edges.l.x, 0, 0)) < pos.distanceTo(new THREE.Vector3(edges.r.x, 0, 0))) {
                        targetSide = 'l';
                    } else {
                        targetSide = 'r';
                    }
                } else {
                    matched = true;
                    targetSide = 'l';
                }
            }
            
            // لو الحجر يطابق أي طرف، نحاول نلزقه
            if(matched && pos.distanceTo(new THREE.Vector3(edges[targetSide].x, 0, 0)) < 3) { // مسافة الالتحام
                snapTile(selected, targetSide);
                played = true;
            }

            if(played) {
                playerHand = playerHand.filter(t => t !== selected);
                boardTiles.push(selected); // نضيفه للحجارة على الطاولة
                updateCounts();
                document.getElementById('msg-bar').innerText = "دور الخصم...";
                selected.position.y = 0.3; // ننزله لمستوى الطاولة
                selected = null;
                drawButton.style.display = 'none'; // نخفي زرار السحب
                setTimeout(aiMove, 1200); // دور الخصم بعد 1.2 ثانية
            } else {
                selected.position.set(selected.userData.ox, 0.3, selected.userData.oz); // يرجع مكانه لو اللعب غلط
                selected.position.y = 0.3;
                selected = null;
                document.getElementById('msg-bar').innerText = "لعب خاطئ. حاول مرة أخرى.";
            }
        });

        drawButton.addEventListener('click', () => {
            if (currentPlayer !== 'p' || bankPool.length === 0) return;

            const drawnTileData = bankPool.pop();
            const newTile = createPremiumTile(drawnTileData.userData.v1, drawnTileData.userData.v2, -3.8 + (playerHand.length * 1.27), 8, 'p');
            playerHand.push(newTile);
            scene.remove(drawnTileData); // نشيل الحجر من مكان البنك
            updateCounts();
            document.getElementById('msg-bar').innerText = `سحبت حجر: ${newTile.userData.v1}-${newTile.userData.v2}. دورك الآن.`;
            checkPlayerMoves(); // بعد السحب نشوف لو فيه لعب جديد
        });

        // --- وظائف اللعب (AI و الالتحام) ---
        function aiMove() {
            let possibleMoves = [];
            for (let i = 0; i < aiHand.length; i++) {
                const tile = aiHand[i];
                if (tile.userData.v1 === edges.l.v || tile.userData.v2 === edges.l.v) {
                    possibleMoves.push({ tile: tile, side: 'l' });
                }
                if (tile.userData.v1 === edges.r.v || tile.userData.v2 === edges.r.v) {
                    possibleMoves.push({ tile: tile, side: 'r' });
                }
            }

            if (possibleMoves.length > 0) {
                // الخصم بيلعب أول حركة ممكنة
                const move = possibleMoves[0];
                const tileToPlay = move.tile;
                
                // نكشف وش الحجر عشان اللاعب يشوفه
                tileToPlay.rotation.x = 0;
                drawPipsForTile(tileToPlay);

                snapTile(tileToPlay, move.side);
                aiHand = aiHand.filter(t => t !== tileToPlay);
                boardTiles.push(tileToPlay);
                updateCounts();
                document.getElementById('msg-bar').innerText = "دورك الآن: اسحب حجر للعب";
                currentPlayer = 'p';
                checkPlayerMoves(); // بعد حركة الخصم، نتحقق من حركات اللاعب
            } else {
                // الخصم يسحب من البنك لو مفيش لعب
                if (bankPool.length > 0) {
                    const drawnTileData = bankPool.pop();
                    const newTile = createPremiumTile(drawnTileData.userData.v1, drawnTileData.userData.v2, -3.8 + (aiHand.length * 1.27), -8, 'ai', true);
                    aiHand.push(newTile);
                    scene.remove(drawnTileData);
                    updateCounts();
                    document.getElementById('msg-bar').innerText = "الخصم سحب حجر. دورك الآن.";
                    currentPlayer = 'p';
                    checkPlayerMoves();
                } else {
                    document.getElementById('msg-bar').innerText = "لا توجد حجارة في البنك. دورك الآن.";
                    currentPlayer = 'p';
                    checkPlayerMoves();
                }
            }
        }

        // دالة مساعدة لرسم النقاط على حجر مكشوف (زي لما الـ AI يكشف حجره)
        function drawPipsForTile(tile) {
            const v1 = tile.userData.v1;
            const v2 = tile.userData.v2;
            const g = 0.38;

            const addDots = (val, zOff) => {
                let pts = [];
                if(val % 2 !== 0) pts.push([0, 0]);
                if(val >= 2) pts.push([g, g], [-g, -g]);
                if(val >= 4) pts.push([-g, g], [g, -g]);
                if(val === 6) pts.push([g, 0], [-g, 0]);

                pts.forEach(p => {
                    const pip = new THREE.Mesh(
                        new THREE.SphereGeometry(0.11, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4 })
                    );
                    pip.position.set(p[0], 0.28, zOff + p[1]);
                    tile.add(pip); // نضيف النقط للحجر مباشرة
                });
            };
            addDots(v1, 0.6);
            addDots(v2, -0.6);
        }

        function snapTile(t, side) {
            const isD = t.userData.isD;
            const target = edges[side];

            // تحريك الحجر لمكان الالتحام
            const targetX = (side === 'r') ? target.x + (isD ? 0.6 : 1.2) : target.x - (isD ? 0.6 : 1.2);
            t.position.set(targetX, 0.3, 0);

            // تدوير الحجر حسب إذا كان دوبل أو عادي
            t.rotation.y = isD ? 0 : Math.PI / 2;
            if (!isD) { // لو مش دوبل، نتأكد إن الرقم الصح هو اللي باصص للطرف اللي التحم بيه
                if ( (t.userData.v1 === target.v && side === 'l') || (t.userData.v2 === target.v && side === 'r')) {
                    t.rotation.y += Math.PI; // نقلب الحجر لو محتاجين
                }
            }

            // تحديث أطراف اللعب الجديدة
            if (t.userData.v1 === target.v) {
                target.v = t.userData.v2;
            } else if (t.userData.v2 === target.v) {
                target.v = t.userData.v1;
            }

            target.x = t.position.x + (side === 'r' ? (isD ? 0.6 : 1.2) : (isD ? -0.6 : -1.2));
            t.userData.owner = 'board'; // الحجر بقى جزء من الطاولة
        }

        // دالة للتحقق إذا كان اللاعب يقدر يلعب أي حجر
        function checkPlayerMoves() {
            let canPlay = false;
            for (let i = 0; i < playerHand.length; i++) {
                const tile = playerHand[i];
                if (tile.userData.v1 === edges.l.v || tile.userData.v2 === edges.l.v ||
                    tile.userData.v1 === edges.r.v || tile.userData.v2 === edges.r.v) {
                    canPlay = true;
                    break;
                }
            }

            if (!canPlay && bankPool.length > 0) {
                drawButton.style.display = 'block'; // نظهر زرار "اسحب من البنك"
                document.getElementById('msg-bar').innerText = "لا يوجد لعب متاح. اسحب من البنك.";
            } else if (!canPlay && bankPool.length === 0) {
                document.getElementById('msg-bar').innerText = "لا يوجد لعب متاح ولا حجارة في البنك. دور الخصم.";
                drawButton.style.display = 'none';
                setTimeout(aiMove, 1200); // الخصم يلعب لو اللاعب ملوش حركة
            } else {
                drawButton.style.display = 'none';
            }
        }

        // --- حلقة الريندر ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        initializeGame(); // بدء اللعبة
        animate(); // بدء الريندر

        // --- استجابة للتغير في حجم الشاشة ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
