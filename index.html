
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Domino Casino 3D - Pro Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui { position: absolute; top: 10px; width: 100%; display: flex; justify-content: center; gap: 15px; pointer-events: none; z-index: 100; }
        .pill { background: linear-gradient(180deg, #444, #000); color: #ffd700; padding: 10px 20px; border-radius: 30px; border: 2px solid #ffd700; font-weight: bold; font-size: 14px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        #msg { position: absolute; bottom: 30px; width: 100%; text-align: center; color: #fff; text-shadow: 2px 2px 4px #000; font-size: 20px; font-weight: bold; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="pill">ðŸ’° 28.5M</div>
        <div class="pill" id="status">Ø§Ù„Ø¹Ø¨ Ø§Ù„Ø¢Ù†</div>
        <div class="pill">ðŸ’¸ 1K</div>
    </div>
    <div id="msg">Ø³Ø­Ø¨ Ø§Ù„Ø­Ø¬Ø± Ù„ØªØ³Ù…Ø¹ "Ø±Ù†Ø©" Ø§Ù„Ø²Ù„Ø·</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Ø§Ù„Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„ØµÙˆØªÙŠØ© (Ø®Ø¨Ø·Ø© Ø²Ù„Ø· Ø­Ø§Ø¯Ø© + Ù…ÙˆØ³ÙŠÙ‚Ù‰) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let musicStarted = false;

        function playClack() {
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = 'square'; 
            osc.frequency.setValueAtTime(900, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.06);
            g.gain.setValueAtTime(0.4, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
            osc.connect(g); g.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        }

        function startAmbient() {
            if(musicStarted) return; musicStarted = true;
            const loop = () => {
                const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
                o.type = 'sine'; o.frequency.setValueAtTime([196, 261, 329][Math.floor(Math.random()*3)], audioCtx.currentTime);
                g.gain.setValueAtTime(0.03, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 3);
                o.connect(g); g.connect(audioCtx.destination);
                o.start(); o.stop(audioCtx.currentTime + 3.5);
                setTimeout(loop, 4000);
            }; loop();
        }

        // --- Ø§Ù„Ù…Ø´Ù‡Ø¯ ÙˆØ§Ù„Ø¥Ø¶Ø§Ø¡Ø© ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 22, 16); camera.lookAt(0, -2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sun = new THREE.SpotLight(0xffffff, 1.2);
        sun.position.set(10, 25, 10); sun.castShadow = true;
        sun.shadow.mapSize.width = 1024; sun.shadow.mapSize.height = 1024;
        scene.add(sun);

        // --- Ø§Ù„Ø·Ø§ÙˆÙ„Ø© Ø§Ù„Ø¹Ø±ÙŠØ¶Ø© ÙˆØ§Ù„Ø¨Ø±ÙˆØ§Ø² Ø§Ù„Ø£Ø­Ù…Ø± ---
        const table = new THREE.Group();
        const felt = new THREE.Mesh(new THREE.BoxGeometry(32, 0.2, 22), new THREE.MeshStandardMaterial({ color: 0x0a3d16 }));
        felt.receiveShadow = true; table.add(felt);

        const woodMat = new THREE.MeshStandardMaterial({ color: 0x4a0a0a, roughness: 0.2, metalness: 0.4 });
        const fL = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 23.2), woodMat); fL.position.set(-16.6, 0.5, 0);
        const fR = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 23.2), woodMat); fR.position.set(16.6, 0.5, 0);
        const fT = new THREE.Mesh(new THREE.BoxGeometry(34.4, 1.2, 1.2), woodMat); fT.position.set(0, 0.5, -11.6);
        const fB = new THREE.Mesh(new THREE.BoxGeometry(34.4, 1.2, 1.2), woodMat); fB.position.set(0, 0.5, 11.6);
        table.add(fL, fR, fT, fB); scene.add(table);

        // --- Ù…ØµÙ†Ø¹ Ø§Ù„Ø­Ø¬Ø± Ø§Ù„Ø¹Ø§Ø¬ÙŠ "Ø§Ù„ØªÙŠØ¨ÙŠÙƒØ§Ù„" ---
        let playerHand = [], leftE = {x: -1.2, val: 6}, rightE = {x: 1.2, val: 6};

        function createTypicalTile(v1, v2, x, z, isHand = false) {
            const group = new THREE.Group();
            const shape = new THREE.Shape();
            const w=1.0, l=2.0, r=0.22; // Ø­ÙˆØ§Ù Ù†Ø§Ø¹Ù…Ø© Ø¬Ø¯Ø§Ù‹
            shape.moveTo(-w/2+r, -l/2); shape.lineTo(w/2-r, -l/2); shape.absarc(w/2-r, -l/2+r, r, 1.5*Math.PI, 0, false);
            shape.lineTo(w/2, l/2-r); shape.absarc(w/2-r, l/2-r, r, 0, 0.5*Math.PI, false);
            shape.lineTo(-w/2+r, l/2); shape.absarc(-w/2+r, l/2-r, r, 0.5*Math.PI, Math.PI, false);
            shape.lineTo(-w/2, -l/2+r); shape.absarc(-w/2+r, -l/2+r, r, Math.PI, 1.5*Math.PI, false);

            const body = new THREE.Mesh(
                new THREE.ExtrudeGeometry(shape, {depth:0.25, bevelEnabled:true, bevelSegments:12, bevelSize:0.05, bevelThickness:0.05}),
                new THREE.MeshStandardMaterial({ color: 0xfafaf5, roughness: 0.05 })
            );
            body.rotation.x = -Math.PI/2; body.castShadow = true; group.add(body);

            // Ù…Ø³Ù…Ø§Ø± Ø§Ù„ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø°Ù‡Ø¨ÙŠ
            const pivot = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 16), new THREE.MeshStandardMaterial({color:0xffd700, metalness:1}));
            pivot.position.y = 0.15; group.add(pivot);

            // Ø®Ø· Ø§Ù„ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø£Ø³ÙˆØ¯
            const line = new THREE.Mesh(new THREE.PlaneGeometry(0.9, 0.04), new THREE.MeshBasicMaterial({color: 0x000000}));
            line.rotation.x = -Math.PI/2; line.position.y = 0.14; group.add(line);

            const drawPips = (val, zOff) => {
                const g=0.32; let p=[];
                if(val%2!==0) p.push([0,0]); if(val>=2) p.push([g,g], [-g,-g]); if(val>=4) p.push([-g,g], [g,-g]); if(val===6) p.push([g,0], [-g,0]);
                p.forEach(pos => {
                    const d = new THREE.Mesh(new THREE.SphereGeometry(0.09,16,16), new THREE.MeshStandardMaterial({color:0x000}));
                    d.position.set(pos[0], 0.13, zOff+pos[1]); group.add(d);
                });
            };
            drawPips(v1, 0.5); drawPips(v2, -0.5);

            group.position.set(x, 0.15, z);
            group.userData = { v1, v2, isHand, ox: x, oz: z, isD: v1===v2 };
            scene.add(group);
            if(isHand) playerHand.push(group);
            return group;
        }

        // ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­Ø¬Ø§Ø±Ø©
        for(let i=0; i<7; i++) createTypicalTile(i, (i+1)%7, -5.5+(i*1.8), 8, true);
        createTypicalTile(6, 6, 0, 0, false);

        // --- Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ Ø§Ù„Ù…Ø·ÙˆØ± ---
        let selected = null;
        const ray = new THREE.Raycaster();
        const m = new THREE.Vector2();

        function onTouchStart(e) {
            if(audioCtx.state === 'suspended') { audioCtx.resume(); startAmbient(); }
            const touch = e.touches[0];
            m.x = (touch.clientX/window.innerWidth)*2-1; m.y = -(touch.clientY/window.innerHeight)*2+1;
            ray.setFromCamera(m, camera);
            const hits = ray.intersectObjects(playerHand, true);
            if(hits.length > 0) {
                let obj = hits[0].object; while(obj.parent && !obj.userData.isHand) obj = obj.parent;
                selected = obj; selected.position.y = 1.5;
            }
        }

        function onTouchMove(e) {
            if(!selected) return;
            const touch = e.touches[0];
            m.x = (touch.clientX/window.innerWidth)*2-1; m.y = -(touch.clientY/window.innerHeight)*2+1;
            ray.setFromCamera(m, camera);
            const ground = ray.intersectObject(felt);
            if(ground.length > 0) selected.position.set(ground[0].point.x, 1.2, ground[0].point.z);
        }

        function onTouchEnd() {
            if(!selected) return;
            let played = false; const p = selected.position;
            if(p.distanceTo(new THREE.Vector3(rightE.x, 0, 0)) < 3.5) { snap(selected, 'right'); played = true; }
            else if(p.distanceTo(new THREE.Vector3(leftE.x, 0, 0)) < 3.5) { snap(selected, 'left'); played = true; }

            if(played) {
                playerHand = playerHand.filter(t => t !== selected);
                playClack();
            } else {
                selected.position.set(selected.userData.ox, 0.15, selected.userData.oz);
            }
            selected.position.y = 0.15; selected = null;
        }

        window.addEventListener('touchstart', onTouchStart, {passive: false});
        window.addEventListener('touchmove', onTouchMove, {passive: false});
        window.addEventListener('touchend', onTouchEnd);

        function snap(tile, side) {
            const isD = tile.userData.isD;
            if(side === 'right') {
                tile.position.set(rightE.x + (isD?0.6:1.1), 0.15, 0);
                tile.rotation.y = isD ? 0 : Math.PI/2;
                rightE.x = tile.position.x + (isD?0.5:1);
            } else {
                tile.position.set(leftE.x - (isD?0.6:1.1), 0.15, 0);
                tile.rotation.y = isD ? 0 : Math.PI/2;
                leftE.x = tile.position.x - (isD?0.5:1);
            }
            tile.userData.isHand = false;
        }

        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
